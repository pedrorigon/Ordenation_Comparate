# -*- coding: utf-8 -*-
"""Cópia de labCPD-01-Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1no98-lIAqNJeZma3CAEA5Hh-s_VVMVGw

# Disciplina de Classificação e Pesquisa de Dados

### Implementação (em Python) dos principais algoritmos de Classificação por Inserção.

A seguir você encontra uma versão do algoritmo de inserção direta com busca linear, que conta a quantidade de trocas e comparações realizadas para ordenar o array passado.

Também encontra um algoritmo de inserção direta com busca binária, que chama uma função auxiliar (incompleta) que faz a busca. Uma de suas atividades do laboratório de hoje é implementar essa função. Não esqueça que as operações de comparação e troca executadas por ela também devem ser consideradas.

Finalmente, encontra a função shellsort (incompleta). Você deve implementar essa função, considerando o que estudamos em aula. Utilize qualquer sequência de intervalos, iniciando pelo maior (mas menor que a quantidade de elementos no array) e diminuindo até que o intervalo seja 1. Não se esqueça de contar a quantidade de comparações e trocas.
"""

# Bibliotecas necessárias ao script:
import numpy as np  # importa a biblioteca numpy (que trabalha com arrays numéricos)
import time         # importa a biblioteca utilizada para contar o tempo
import pandas as pd # biblioteca para trabalhar com data frames
import math

################################################
# Algoritmos de ordenação
################################################

# Função de Inserção Direta com Busca Linear
def insertion_sort(array): 
    trocas = comparacoes = 0
    for i in range(1, len(array)):             # do segundo ao último (o primeiro faz parte do subarray ordenado)
        chave = array[i]                       # chave a inserir no subarray ordenado
        j = i-1                                # último elemento do subarray ordenado         
        while (j >= 0) and (array[j] > chave): # busca linear da direita para a esquerda no subarray ordenado            
            comparacoes = comparacoes + 1
            array[j+1] = array[j]
            j = j -1
            trocas = trocas + 1
        array[j+1] = chave
        trocas = trocas + 1
    return {'trocas':trocas, 'comparacoes':comparacoes}                         # retorna quantidade de operações

def insertion_sortBB(array):  
    log_operacoes = { 'comparacoes': 0, 'trocas': 0 }
    
    for i in range(1, len(array)): 
        resultado = busca_binaria(array, array[i], 0, i-1, log_operacoes)
        
        if resultado['posicao'] < i:
            tmp = array[i]                                                      # A
            for j in reversed(range(resultado['posicao'], i)):                  # do último ao primeiro elemento do segmento, abre espaço para inserir o elemento na posição retornada pela busca binária
                array[j+1] = array[j]
                log_operacoes['trocas'] = log_operacoes['trocas'] + 1
            array[resultado['posicao']] = tmp            
            log_operacoes['trocas'] = log_operacoes['trocas'] + 1               # B
            # O trecho entre A e B pode ser trocado por: array = array[:resultado['posicao']] +array[i]+array[resultado['posicao']:i] + array[i+1:], mas daí não conseguiremos contar as operações.
        
    return log_operacoes

################################################
# Implementação dos seus algoritmos:

# Faz busca binária do 'elemento' no 'array', entre os índices 'inicio' e 'fim':
def busca_binaria(array, elemento, inicio, fim, log_operacoes):    
    if inicio>fim:  #Testa se o elemento está presente
        log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
        return {'posicao': inicio, 'log_operacoes': log_operacoes }
    meio = (inicio + fim) // 2
    if array[meio] == elemento:  #Testa se o elemento está no meio do arranjo
        log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
        return meio
    elif array[meio] > elemento:
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      return busca_binaria(array, elemento, inicio, meio - 1, log_operacoes)
    else:
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1
      return busca_binaria(array, elemento, meio + 1, fim, log_operacoes)  
    return {'posicao': meio, 'log_operacoes': log_operacoes }

def shell_sort(array):
    trocas = comparacoes = 0
    # Dividindo o vetor em h segmentos
    distancia = len(array) // 2
    while distancia > 0:
        comparacoes = comparacoes + 1
        auxdistancia = distancia
        while auxdistancia < len(array):
            comparacoes = comparacoes + 1
            chave = array[auxdistancia]  # chave a inserir no subarray ordenado
            j = auxdistancia-distancia                                # último elemento do subarray ordenado
            while (j >= 0) and (array[j] > chave):
                comparacoes = comparacoes + 1
                array[j+distancia] = array[j]
                j = j - distancia
                trocas = trocas + 1
                array[j+distancia] = chave
                trocas = trocas + 1
            auxdistancia = auxdistancia + 1
        distancia = distancia // 2    
    return {'trocas': trocas, 'comparacoes': comparacoes}

# Avaliação do desempenho de diferentes algoritmos para diferentes quantidades de números

# Variáveis globais necessárias:
gerador = np.random.RandomState()  # cria um gerador de números aleatórios (descomente se for usar array aleatório)
medicoes = []                      # lista que armazena os resultados das medições em memória

# lista de algoritmos a testar (insira o seu, caso elabore outros):
algoritmos = { 
    'ISBL': { 'nome': 'Inserção Direta com Busca Linear', 'funcao': insertion_sort },
    'ISBB': { 'nome': 'Inserção Direta com Busca Binária', 'funcao': insertion_sortBB },
    'ISSH': { 'nome': 'Inserção por ShellSort', 'funcao': shell_sort },
    # insira o seu aqui usando a sintaxe acima
}  

# testa o desempenho dos algoritmos para diferentes quantidades (múltiplos de 10):
for qtd in [10**x for x in range(2, 5)]:
    max = qtd
    array = gerador.randint(0, max+1, qtd)          # gera array aleatório com 'qtd' números entre 0 e 'max'    
    array = list(range(qtd, 0, -1))                   # array decrescente (pior caso)
    
    print('---------------------------------------------------')
    print('Testando algoritmos com array de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='R'
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                              # adiciona medição em uma lista de medições

print('Fim do processamento!')

# Cria dataframe pandas (i.e., uma tabela) que organiza os dados relacionados com a execução dos algorimos acima
df = pd.DataFrame(medicoes)
cols = ['algoritmo', 'tipo', 'quantidade', 'trocas', 'comparacoes', 'tempo']  # ordem correta das colunas 
df = df[cols]

print(df) # imprime os dados de execução dos algoritmos

# agrupa resultados por algoritmo:
df_by_algorithm = df.groupby(['algoritmo']) 

for key, item in df_by_algorithm:
    print(df_by_algorithm.get_group(key), "\n\n")

# seleciona somente sigla e tempo:
tmp = df[['algoritmo','quantidade','tempo']]
tmp = tmp.groupby(['algoritmo']) 
for key, item in df_by_algorithm:
    print(df_by_algorithm.get_group(key), "\n\n")

# Commented out IPython magic to ensure Python compatibility.
# plota gráficos dos dados gerados

# habilita a geração de gráficos direto nas células do Jupyter:
# %matplotlib inline 

#importa biblioteca de geração e manipulação de gráficos
import matplotlib.pyplot as plt

tmp.plot(x='quantidade', y='tempo', ax=plt.gca())
plt.legend(df['algoritmo'].unique())
plt.ylabel('tempo')

